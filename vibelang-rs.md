---
title: vibelang-rs
layout: default
---

# Vibelang-rs

A Rust implementation of the Vibelang protocol. Use Meaning Typed Prompting to create your AI Agents from a verified and validated source definition. From formal definition to safe code for agents deployment:

## Try Vibelang (mockup):

<div class="code-block">
<pre><code>
// <span class="comment">A comprehensive example showcasing various Meaning-Oriented Programming (MTP) features using Vibelang.</span>
// <span class="comment">Comments are just for explanation purposes, they are not part of the protocol and can be omitted.</span>



// <span class="comment">These types tell the compiler and runtime what the data represents.</span>
type Population = Meaning&lt;Int&gt;("population count in millions");
type HistoricalFact = Meaning&lt;String&gt;("historical information");
type YearFounded = Meaning&lt;Int&gt;("year when established");
type GeographicInfo = Meaning&lt;String&gt;("geographic description");



// --- VibeLang Functions ---



// <span class="comment">Functions for knowledge retrieval about a country</span>
<span class="function">fn get_population(country: String) -&gt; Population {</span>
    prompt "What is the current population of {country} in millions? Reply with just the number.";
}

<span class="comment">// Note: This function uses a raw String return type without a specific Meaning.</span>
<span class="function">fn get_capital(country: String) -&gt; String {</span>
    prompt "What is the capital city of {country}? Reply with just the city name.";
}

<span class="function">fn get_founding_year(country: String) -&gt; YearFounded {</span>
    prompt "In what year was {country} founded or established as a nation? Reply with just the year.";
}


// <span class="comment">Function to get information about a person or landmark</span>
<span class="function">fn get_historical_fact(person: String) -&gt; HistoricalFact {</span>
    prompt "Tell me one interesting historical fact about {person}. Keep it to one sentence.";
}

<span class="function">fn get_geographic_info(landmark: String) -&gt; GeographicInfo {</span>
    prompt "Describe the geographic location and features of {landmark} in one sentence.";
}


// <span class="comment">Function for text analysis</span>
<span class="function">fn analyze_sentiment(text: String) -&gt; Meaning&lt;String&gt;("emotional sentiment") {</span>
    prompt "Analyze the emotional sentiment of this text: '{text}'. Reply with either 'positive', 'negative', or 'neutral'.";
}


// <span class="comment">Function for simple calculation</span>
<span class="function">fn calculate_age(birth_year: Int) -&gt; Meaning&lt;Int&gt;("age calculation") {</span>
    prompt "If someone was born in {birth_year}, how old would they be in 2025? Reply with just the number.";
}
</code></pre>
</div>
<br>
<button id="compileBtn" class="pure-button pure-button-primary">Compile</button>

<div id="outputWrapper" style="display:none; margin-top:1em;">
  <pre id="output" style="background:#111;color:#f8f8f2;border-radius:5px;padding:1em;overflow-x:auto;">// Rust output will appear here</pre>
  This code is now ready to be embedded in AI Agents workflows. It is formally safe for distributed computing use and guarantees all
the safeguards of Rust code in terms of performance and security. 
</div>

<script>
function autoResize(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
}
// Auto-resize on page load, fit code block immediately:
window.addEventListener('DOMContentLoaded', function() {
    var textarea = document.getElementById('input');
    autoResize(textarea);
});

document.getElementById('compileBtn').addEventListener('click', function() {
    var outputDiv = document.getElementById('outputWrapper');
    outputDiv.style.display = outputDiv.style.display === 'none' ? 'block' : 'none';
    var outputBox = document.getElementById('output');
    if (outputDiv.style.display === 'block') {
        outputBox.textContent = `// Generated by VibeLang-rs Compiler
// MIT License
// Copyright (c) 2025 Mec-iS
// This file is generated from a template. Do not edit manually.

use vibelang::runtime::{
    client::LlmClient,
    types::VibeValue,
};
use vibelang::runtime::llm_provider::LlmProvider;

// --- MTP Type Definitions ---

// Semantic meaning: "population count in millions"
pub type Population = i32;

// Semantic meaning: "historical information"
pub type HistoricalFact = String;

// Semantic meaning: "year when established"
pub type YearFounded = i32;

// Semantic meaning: "geographic description"
pub type GeographicInfo = String;


// --- Semantic Extraction Utilities ---

fn extract_generic_number(text: &str) -> i32 {
    text.split_whitespace()
        .find_map(|word| word.parse::<i32>().ok())
        .unwrap_or(0)
}

fn extract_generic_float(text: &str) -> f64 {
    text.split_whitespace()
        .find_map(|word| word.parse::<f64>().ok())
        .unwrap_or(0.0)
}



fn extract_year_when_established_value(text: &str) -> i32 {
    
    extract_generic_number(text)
    
}

fn extract_population_count_millions_value(text: &str) -> i32 {
    
    extract_generic_number(text)
    
}



fn extract_geographic_description_value(text: &str) -> String {
    
    text.trim().to_string()
    
}

fn extract_historical_information_value(text: &str) -> String {
    
    text.trim().to_string()
    
}



// --- Semantic Parser Dispatch ---
fn parse_semantic_response(content: &str, meaning: Option<&str>, return_type: &str) -> VibeValue {
    match return_type {
        "i32" => {
            let value = match meaning {
                
                Some("year when established") => extract_year_when_established_value(content),
                Some("population count in millions") => extract_population_count_millions_value(content),
                _ => extract_generic_number(content),
            };
            VibeValue::Number(value as f64)
        }
        "f64" => {
            let value = match meaning {
                
                _ => extract_generic_float(content),
            };
            VibeValue::Number(value)
        }
        "bool" => {
            let b = content.trim().to_lowercase();
            VibeValue::Boolean(b == "true" || b == "yes" || b == "1")
        }
        _ => { // Default to String
            let value = match meaning {
                 
                Some("geographic description") => extract_geographic_description_value(content),
                Some("historical information") => extract_historical_information_value(content),
                _ => content.trim().to_string(),
            };
            VibeValue::String(value)
        }
    }
}

// --- Core Runtime Execution ---
fn vibe_execute_prompt(llm: &LlmClient, prompt: &str, meaning: Option<&str>, return_type: &str) -> VibeValue {
    let enhanced_prompt = match meaning {
        Some(m) => format!("Context: You are an AI assistant that must perform a specific task. The user wants a value that has the semantic meaning of \"{}\". Please provide a concise answer based on the following query.\n\nQuery: {}", m, prompt),
        None => prompt.to_string(),
    };

    match llm.generate(&enhanced_prompt) {
        Ok(response) => parse_semantic_response(&response, meaning, return_type),
        Err(e) => {
            eprintln!("LLM execution failed: {}", e);
            VibeValue::Null
        }
    }
}

// --- Generated VibeLang Functions ---

pub fn get_population(llm: &LlmClient, country: String) -> Population {
    let mut template = "What is the current population of {country} in millions? Reply with just the number.".to_string();
    
    template = template.replace("{country}", &country.to_string());
    
    
    let meaning = Some("population count in millions");
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "i32";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
    
    result.into_i32()
    
}

pub fn get_capital(llm: &LlmClient, country: String) -> String {
    let mut template = "What is the capital city of {country}? Reply with just the city name.".to_string();
    
    template = template.replace("{country}", &country.to_string());
    
    
    let meaning = None;
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "String";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
     // Assumes String or a type aliased to String
    result.into_string()
    
}

pub fn get_founding_year(llm: &LlmClient, country: String) -> YearFounded {
    let mut template = "In what year was {country} founded or established as a nation? Reply with just the year.".to_string();
    
    template = template.replace("{country}", &country.to_string());
    
    
    let meaning = Some("year when established");
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "i32";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
    
    result.into_i32()
    
}

pub fn get_historical_fact(llm: &LlmClient, person: String) -> HistoricalFact {
    let mut template = "Tell me one interesting historical fact about {person}. Keep it to one sentence.".to_string();
    
    template = template.replace("{person}", &person.to_string());
    
    
    let meaning = Some("historical information");
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "String";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
     // Assumes String or a type aliased to String
    result.into_string()
    
}

pub fn get_geographic_info(llm: &LlmClient, landmark: String) -> GeographicInfo {
    let mut template = "Describe the geographic location and features of {landmark} in one sentence.".to_string();
    
    template = template.replace("{landmark}", &landmark.to_string());
    
    
    let meaning = Some("geographic description");
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "String";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
     // Assumes String or a type aliased to String
    result.into_string()
    
}

pub fn analyze_sentiment(llm: &LlmClient, text: String) -> String {
    let mut template = "Analyze the emotional sentiment of this text: '{text}'. Reply with either 'positive', 'negative', or 'neutral'.".to_string();
    
    template = template.replace("{text}", &text.to_string());
    
    
    let meaning = Some("emotional sentiment");
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "String";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
     // Assumes String or a type aliased to String
    result.into_string()
    
}

pub fn calculate_age(llm: &LlmClient, birth_year: i32) -> i32 {
    let mut template = "If someone was born in {birth_year}, how old would they be in 2025? Reply with just the number.".to_string();
    
    template = template.replace("{birth_year}", &birth_year.to_string());
    
    
    let meaning = Some("age calculation");
    // The string passed to the runtime is the base type, not the alias.
    let return_type_str = "i32";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // The logic now uses 'func.return_base_type' to generate the correct conversion call.
    
    result.into_i32()
    
}



// --- Main application entry point ---
fn main() -> anyhow::Result<()> {
    println!("VibeLang program compiled: 🔎 Checking for a local Ollama instance 🔎");
    println!("VibeLang program compiled: ⚠️ 'generated/src/main.rs' change the test values to meaningful values ⚠️");

    // 1. Set up the LLM Client
    // This reads OLLAMA_BASE_URL and OLLAMA_MODEL from your environment.
    println!("Setting up LLM client...");
    let config = vibelang::config::Config::from_env();
    let client = vibelang::runtime::client::LlmClient::new(config)?;

    // 2. Dynamically call all generated functions with test values
    
    println!("\n--- Calling function: get_population ---");
    // Call the function with auto-generated test parameters.
    let result_get_population = get_population(
        &client,
        "Test Topic".to_string()  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for get_population: {:?}", result_get_population);
    
    println!("\n--- Calling function: get_capital ---");
    // Call the function with auto-generated test parameters.
    let result_get_capital = get_capital(
        &client,
        "Test Topic".to_string()  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for get_capital: {:?}", result_get_capital);
    
    println!("\n--- Calling function: get_founding_year ---");
    // Call the function with auto-generated test parameters.
    let result_get_founding_year = get_founding_year(
        &client,
        "Test Topic".to_string()  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for get_founding_year: {:?}", result_get_founding_year);
    
    println!("\n--- Calling function: get_historical_fact ---");
    // Call the function with auto-generated test parameters.
    let result_get_historical_fact = get_historical_fact(
        &client,
        "Test Topic".to_string()  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for get_historical_fact: {:?}", result_get_historical_fact);
    
    println!("\n--- Calling function: get_geographic_info ---");
    // Call the function with auto-generated test parameters.
    let result_get_geographic_info = get_geographic_info(
        &client,
        "Test Topic".to_string()  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for get_geographic_info: {:?}", result_get_geographic_info);
    
    println!("\n--- Calling function: analyze_sentiment ---");
    // Call the function with auto-generated test parameters.
    let result_analyze_sentiment = analyze_sentiment(
        &client,
        "Test Topic".to_string()  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for analyze_sentiment: {:?}", result_analyze_sentiment);
    
    println!("\n--- Calling function: calculate_age ---");
    // Call the function with auto-generated test parameters.
    let result_calculate_age = calculate_age(
        &client,
        123  // <-------------- CHANGE THE TEST VALUE
    );
    println!("Result for calculate_age: {:?}", result_calculate_age);
    

    Ok(())
}
`;
    }
});
</script>

## Github

**Try agentic programming with Vibelang in Rust—define LLM agents, workflows, and interactions using Meaning Typed Prompting (MTP).**
The project enables precise, annotated payloads for reliable and explainable agent creation. Powered by Rust’s speed, safety, and clarity.

**[Visit Vibelang-rs on GitHub](https://github.com/Mec-iS/vibelang-rs)**
If you find the project useful or inspiring, please **star the repository** to help grow the research and its open-source community!
